---
title: "Introduction to `DyadBoot`"
date: "2023-09-14"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to `DyadBoot`}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Introduction

`DyadBoot` provides tools for dyadic random bootstrapping and analysis. It is indicated for experimental data involving dyads, in which effects want to be explored at the individual level. It is important to note that it requires 1) there to be a column pertaining to the Dyad (e.g. "Dyad_id"), 2) that each invidual is on a different row, and 3) for individuals belonging to the same dyad to be in adjecent rows. Example provided below:

-Example-

Original Data

```{r}
library(knitr)

data <- data.frame(
  Dyad_id = c("Trial1", "Trial1", "Trial2", "Trial2", "Trial3", "Trial3"),
  Individual = c(100, 101, 102, 103, 104, 105),
  Treatment = c("High protein", "Low protein", "Low protein", "High protein", "High protein", "Low protein"),
  `Body mass (g)` = c(0.5, 0.433, 0.552, 0.601, 0.342, 0.56)
)

kable(data)
```

With DyadBoot::randOne, DyadBoot::randMult or DyadBoot::randBoot

```{r}
library(knitr)

data <- data.frame(
  Dyad_id = c("Trial1", "Trial2", "Trial3"),
  focal_Individual = c(100, 102, 104),
  opposite_Individual = c(101, 103, 105),
  focal_Treatment = c("High protein", "Low protein", "High protein"),
  opposite_Treatment = c("Low protein", "High protein", "Low protein"),
  focal_Body_Size = c(0.5, 0.552, 0.342),
  opposite_Body_Size = c(0.433, 0.601, 0.56)
)

kable(data)
```

## Installation

You can install the package from GitHub using `devtools`:

```{r eval=FALSE}
install.packages("devtools")
devtools::install_github("toomanycrickets/DyadBoot")

```

## Functions:

1.  'randBoot' - Randomly assigns the role of "focal" and "opposite" to each individual of each dyad. Bootstrapping is then performed on the chosen model (package only supports lm, glm, lmer, and glmer so far). The random assignment of "focal" and "ooposite" roles occurs at every iteration of the bootstrapping to mitigate random sampling bias. The output includes "results$bootstrap_results", a string of all summary tables from each bootstrapping iteration, and "results$anova_results", a string of all Anova tables from each bootstrapping iteration.

```{r eval=FALSE}
model_formula <- dependent_variable ~ independent_variable #specify model formula. It takes the format generated by the randBoot function with the "focal" and "opposite" roles attributed. Example: model_formula <- focal_aggression ~ opposite_mass

results <- DyadBoot::randBoot(data = data,
                           dyad_id_col = "dyad_id",
                           model_formula = model_formula,
                           model_type = "lm",
                           n_bootstraps = 1000,
                           focal_cols = c("dependent_variable"), 
                           opposite_cols = c("dependent_variable"))

#"focal_cols" and "opposite_cols" both take the original name of the variable, without the attribution of "focal" or "opposite". Must be same variable. 
#Example: (...) focal_cols = c("aggression"), 
               #opposite_cols = c("aggression"))
               
results$bootstrap_results #for list of all summary(model) performed in the bootstrapping
results$anova_results #for list of all car::Anova(model) performed in the bootstrapping
```

------------------------------------------------------------------------

2.  'randOne' - To only perform the random assignment of roles without performing the bootstrapping step. Returns a dataset called "focal_opposite_data". Useful for testing model assumptions before analysis.

```{r eval=FALSE}
focal_opposite_data <- DyadBoot::randOne(data = data, dyad_id_col = "your_dyad_column_name")
```

------------------------------------------------------------------------

3.  'randMult' - To perform the random assignment of roles a specified number of times without performing the bootstrapping step. Returns a list with all datasets.

```{r eval=FALSE}
resultsMult <- randMult(data, dyad_id_col = "your_dyad_column_name", num_iterations = number_of_iterations_desired)

resultsMult$results_list #access all datasets
```

------------------------------------------------------------------------

4.  'repDataSet' - Takes 'randMult' output as input and chooses the most representative dataset for the particular variables specified (whereby the mean for that dataset is closest to the overall mean of all datasets generated by randMult). Also provides a dataframe that contains the mean for the categorical variable of interested for all its levels - for all datasets (the number of rows in this dataframe is the number of datasets. The number of columns is the number of levels of the categorical variable).

```{r eval=FALSE}
rep_data<- DyadBoot::repDataSet(resultsMult, "numerical_variable", "categorical_variable1", "categorical_variable2")

rep_data$closest_data #access most representative dataset
rep_data$each_dataset_means #access dataframe with means for each level of the categorical variable for each dataset generated by randMult
```

------------------------------------------------------------------------

5.  ‘averages’ - Takes the output of DyadBoot::randBoot as input and returns a table with the averages of all coeficients (e.g. estimate, standard error, z-value, p-value) (for each tested factor) from all iterations of the bootstrapping. Also provides standard errors of these averages. Handles output from summary() and car::Anova() functions.


```{r eval=FALSE}
DyadBoot::averages(results$bootstrap_results) # summary
DyadBoot::averages(results$anova_results) # Anova

```

------------------------------------------------------------------------

6.  ‘countPvals’ - Takes the output of DyadBoot::randBoot as input and returns the number of times each tested factor is statistically significant (p-value < 0.05). Handles output from summary() and car::Anova() functions.


```{r eval=FALSE}
DyadBoot::countPvals(results$bootstrap_results) # summary
DyadBoot::countPvals(results$anova_results) # Anova

```

------------------------------------------------------------------------

7.  'anovaPvals' - Extracts all P-values from the Anova output generated by DyadBoot::randBoot (results\$anova_results) for the specified factor.

```{r eval=FALSE}
pvals<-DyadBoot::anovaPvals(results$anova_results, "factor_name")
```

------------------------------------------------------------------------

8.  'MeanOfMeans' - Calculates the overall mean of all bootstrap iterations of a specified numerical variable for all levels of a specified categorical variable.

```{r eval=FALSE}
overall_means <- DyadBoot::MeanOfMeans(mrep_data$each_dataset_means, "numerical_variable", "categorical_variable1", "categorical_variable2") 

#each_dataset_means is one of the outputs of DyadBoot::repDataSet, a dataframe that contains the mean for the categorical variable of interested for all its levels - for each dataset generated by DyadBoot::randMult. 
```

------------------------------------------------------------------------

9.  'histMeans' - Histogram of distribution of means for specified level of specified categorical variable.

```{r eval=FALSE}
histMeans(each_dataset_means, numerical_variable, categorical_variable, level) #each_dataset_means is one of the outputs of DyadBoot::repDataSet, a dataframe that contains the mean for the categorical variable of interested for all its levels (can be accessed via rep_data$each_dataset_means) - for each dataset generated by DyadBoot::randMult. 
```

------------------------------------------------------------------------

10.  'histPvals' - Histogram of the distribution of all p-values for the selected factor. Chose either the output from the summary function or the Anova function. Text within the plot specifies the number of iterations that the selected factor had a significant p-value.

```{r eval=FALSE}

# Using summary function output
DyadBoot::histPvals(results$bootstrap_results, "your_coefficient_name", "Summary")

# Using Anova function output
DyadBoot::histPvals(results$bootstrap_results, "your_coefficient_name", "Anova")
```

------------------------------------------------------------------------

11. 

'plotBoot' - Two grid plot. Left grid -raincloud plot (with boxplot) of the most representative dataset with overlay of overall mean for the specified variable. Right grid - Histogram of pvalues with red dashed line at 0.05.

```{r eval=FALSE}
plot1<-DyadBoot::plotBoot(rep_data$closest_data, "numerical_variable", "categorical_variable1", "categorical_variable2", overall_means = overall_means, 
               xlab_name = "name", ylab_name = "name", main_title = "name", p_values = pvals)
               
plot1 #to generate plot

#overall_means is the output of fucntion DyadBoot::MeanOfMeans
#pvals is list of p-values of factor of interest, output of DyadBoot::anovaPvals.
```




## Running functions with example data:

```{r}
library(DyadBoot)
data("mydata", package = "DyadBoot")
# Check if the dataset is loaded correctly
if (!exists("mydata")) {
  stop("The 'mydata' dataset could not be loaded.")
}
head(mydata)


model_formula <- focal_Aggression_Duration ~ focal_Genotype * focal_Song_occurrence #specify model formula. It takes the format generated by the randBoot function with the "focal" and "opposite" roles attributed. Example: model_formula <- focal_aggression ~ opposite_mass

results <- DyadBoot::randBoot(data = mydata,
                              dyad_id_col = "Trial_ID",
                              model_formula = model_formula,
                              model_type = "lm",
                              n_bootstraps = 1000,
                              focal_cols = c("Aggression_Duration"), 
                              opposite_cols = c("Aggression_Duration"))

#"focal_cols" and "opposite_cols" both take the original name of the variable, without the attribution of "focal" or "opposite". Must be same variable. 
#Example: (...) focal_cols = c("aggression"), 
#opposite_cols = c("aggression"))

head(results$bootstrap_results) #for list of all summary(model) performed in the bootstrapping
```


```{r}
head(results$anova_results) #for list of all car::Anova(model) performed in the bootstrapping

```


```{r}
DyadBoot::averages(results$bootstrap_results)

```

histPvals - From summary() or car::Anova() output
```{r, fig.width=8, fig.height=6}
DyadBoot::histPvals(results$bootstrap_results, coeff_name = "focal_GenotypeB:focal_Song_occurrenceYes", "Summary")
DyadBoot::histPvals(results$anova_results, coeff_name = "focal_Genotype:focal_Song_occurrence", "Anova")


```

From car::Anova() function
```{r}
pvals<-DyadBoot::anovaPvals(results$anova_results, "focal_Genotype:focal_Song_occurrence")
head(pvals)

```


```{r}
resultsMult <- DyadBoot::randMult(mydata, dyad_id_col = "Trial_ID", num_iterations = 1000)

```


```{r}
rep_data<- DyadBoot::repDataSet(resultsMult, "focal_Aggression_Duration", "focal_Genotype", "focal_Song_occurrence")

head(rep_data$closest_data) #access most representative dataset
head(rep_data$each_dataset_means) #access dataframe with means for each level of the categorical variable for each dataset generated by randMult


```



```{r}
overall_means <- DyadBoot::MeanOfMeans(rep_data$each_dataset_means, "focal_Aggression_Duration", "focal_Genotype", "focal_Song_occurrence") 
head(overall_means)

```


Without p-values
```{r, fig.width=5, fig.height=3.5}
plot <- DyadBoot::plotBoot(rep_data$closest_data, "focal_Aggression_Duration", "focal_Genotype", "focal_Song_occurrence", overall_means = overall_means, 
                            xlab_name = "Genotype", ylab_name = "Focal Duration of Aggression (s)", main_title = NULL)

plot #to generate plot
```

With p-values - use either plotBoot or plotBoot1 (width parameters differ)
```{r eval=FALSE}
plot1 <- DyadBoot::plotBoot1(rep_data$closest_data, "focal_Aggression_Duration", "focal_Genotype", "focal_Song_occurrence", overall_means = overall_means, 
                            xlab_name = "Genotype", ylab_name = "Focal Duration of Aggression (s)", main_title = NULL, p_values = pvals)

plot1 #to generate plot
```
---
------------------------------------------------------------------------
