return(p)
}
tryy<-plotBoot(representative_data$closest_data, "focal_dant", "focal_morph", representative_data$overall_means)
tryy
plotBoot <- function(closest_data, num_var, cat_var, overall_means) {
library(ggplot2)
# Calculate dataset means for each level
dataset_means <- tapply(closest_data[[num_var]], closest_data[[cat_var]], mean, na.rm = TRUE)
# Extract categorical levels and their means from the overall_means vector
cat_levels <- if (is.null(names(overall_means))) {
unique(closest_data[[cat_var]])
} else {
names(overall_means)
}
mean_values <- as.numeric(overall_means)
# Ensure cat_levels and mean_values are of the same length
if (length(cat_levels) != length(mean_values)) {
stop("Mismatch between categorical levels and their overall means.")
}
# Plot the violin plot
p <- ggplot(closest_data, aes(x = get(cat_var), y = get(num_var))) +
geom_violin(aes(fill = get(cat_var)), alpha = 0.7) +
geom_jitter(width = 0.2, size = 1, alpha = 0.7, shape = 20) +  # Change here
geom_point(data = data.frame(cat = names(dataset_means), mean = dataset_means),
aes(x = cat, y = mean), color = "#E17C57", size = 3, shape = 18) +
geom_point(data = data.frame(cat = cat_levels, mean = mean_values),
aes(x = cat, y = mean), color = "#FFE5CC", size = 3, shape = 5) +
labs(title = paste("Violin plot of", num_var, "by", cat_var),
x = cat_var, y = num_var, fill = cat_var) +
theme_gray() +
scale_fill_manual(values = c("Fw" = "#42C092", "Nw" = "#42ABC0"))
return(p)
}
tryy<-plotBoot(representative_data$closest_data, "focal_dant", "focal_morph", representative_data$overall_means)
tryy
plotBoot <- function(closest_data, num_var, cat_var, overall_means) {
library(ggplot2)
# Calculate dataset means for each level
dataset_means <- tapply(closest_data[[num_var]], closest_data[[cat_var]], mean, na.rm = TRUE)
# Extract categorical levels and their means from the overall_means vector
cat_levels <- if (is.null(names(overall_means))) {
unique(closest_data[[cat_var]])
} else {
names(overall_means)
}
mean_values <- as.numeric(overall_means)
# Ensure cat_levels and mean_values are of the same length
if (length(cat_levels) != length(mean_values)) {
stop("Mismatch between categorical levels and their overall means.")
}
# Plot the violin plot
p <- ggplot(closest_data, aes(x = get(cat_var), y = get(num_var))) +
geom_violin(aes(fill = get(cat_var)), alpha = 0.7) +
geom_jitter(width = 0.2, size = 1, alpha = 0.7, shape = 20) +  # Change here
geom_point(data = data.frame(cat = names(dataset_means), mean = dataset_means),
aes(x = cat, y = mean), color = "#E17C57", size = 3, shape = 18) +
geom_point(data = data.frame(cat = cat_levels, mean = mean_values),
aes(x = cat, y = mean), color = "#FFE5CC", size = 2, shape = 5) +
labs(title = paste("Violin plot of", num_var, "by", cat_var),
x = cat_var, y = num_var, fill = cat_var) +
theme_gray() +
scale_fill_manual(values = c("Fw" = "#42C092", "Nw" = "#42ABC0"))
return(p)
}
tryy<-plotBoot(representative_data$closest_data, "focal_dant", "focal_morph", representative_data$overall_means)
tryy
plotBoot <- function(closest_data, num_var, cat_var, overall_means) {
library(ggplot2)
# Calculate dataset means for each level
dataset_means <- tapply(closest_data[[num_var]], closest_data[[cat_var]], mean, na.rm = TRUE)
# Extract categorical levels and their means from the overall_means vector
cat_levels <- if (is.null(names(overall_means))) {
unique(closest_data[[cat_var]])
} else {
names(overall_means)
}
mean_values <- as.numeric(overall_means)
# Ensure cat_levels and mean_values are of the same length
if (length(cat_levels) != length(mean_values)) {
stop("Mismatch between categorical levels and their overall means.")
}
# Plot the violin plot
p <- ggplot(closest_data, aes(x = get(cat_var), y = get(num_var))) +
geom_violin(aes(fill = get(cat_var)), alpha = 0.7) +
geom_jitter(width = 0.2, size = 1, alpha = 0.7, shape = 20) +  # Change here
geom_point(data = data.frame(cat = names(dataset_means), mean = dataset_means),
aes(x = cat, y = mean), color = "#E17C57", size = 4, shape = 18) +
geom_point(data = data.frame(cat = cat_levels, mean = mean_values),
aes(x = cat, y = mean), color = "#FFE5CC", size = 4, shape = 5) +
labs(title = paste("Violin plot of", num_var, "by", cat_var),
x = cat_var, y = num_var, fill = cat_var) +
theme_gray() +
scale_fill_manual(values = c("Fw" = "#42C092", "Nw" = "#42ABC0"))
return(p)
}
tryy<-plotBoot(representative_data$closest_data, "focal_dant", "focal_morph", representative_data$overall_means)
tryy
plotBoot <- function(closest_data, num_var, cat_var, overall_means) {
library(ggplot2)
# Calculate dataset means for each level
dataset_means <- tapply(closest_data[[num_var]], closest_data[[cat_var]], mean, na.rm = TRUE)
# Extract categorical levels and their means from the overall_means vector
cat_levels <- if (is.null(names(overall_means))) {
unique(closest_data[[cat_var]])
} else {
names(overall_means)
}
mean_values <- as.numeric(overall_means)
# Ensure cat_levels and mean_values are of the same length
if (length(cat_levels) != length(mean_values)) {
stop("Mismatch between categorical levels and their overall means.")
}
# Plot the violin plot
p <- ggplot(closest_data, aes(x = get(cat_var), y = get(num_var))) +
geom_violin(aes(fill = get(cat_var)), alpha = 0.7) +
geom_jitter(width = 0.2, size = 1, alpha = 0.7, shape = 20) +  # Change here
geom_point(data = data.frame(cat = names(dataset_means), mean = dataset_means),
aes(x = cat, y = mean), color = "#E17C57", size = 4, shape = 18) +
geom_point(data = data.frame(cat = cat_levels, mean = mean_values),
aes(x = cat, y = mean), color = "#FFE5CC", size = 4, shape = 18) +
labs(title = paste("Violin plot of", num_var, "by", cat_var),
x = cat_var, y = num_var, fill = cat_var) +
theme_gray() +
scale_fill_manual(values = c("Fw" = "#42C092", "Nw" = "#42ABC0"))
return(p)
}
tryy<-plotBoot(representative_data$closest_data, "focal_dant", "focal_morph", representative_data$overall_means)
tryy
resultsMult <- randMult(mydata, dyad_id_col = "dyad_id", num_iterations = 1000)
histMeans <- function(all_means, num_var, cat_var, level) {
library(ggplot2)
# Extract the means for the specified level
means_for_level <- all_means[[level]]
# Calculate the overall mean for the specified level
overall_mean <- mean(means_for_level, na.rm = TRUE)
# Plot the histogram
p <- ggplot(data.frame(means = means_for_level), aes(x = means)) +
geom_histogram(binwidth = 0.1, fill = "lightblue", color = "black", alpha = 0.7) +
geom_vline(aes(xintercept = overall_mean), color = "red", linetype = "dashed", size = 1) +
labs(title = paste("Distribution of means for", num_var, "when", cat_var, "is", level),
x = "Mean", y = "Count")
return(p)
}
plot<-histMeans(representative_data$all_means, "focal_dant", "focal_morph", "Nw")
plot
resultsMult$results_list
plotBoot <- function(closest_data, num_var, cat_var, overall_means) {
library(ggplot2)
# Calculate dataset means for each level
dataset_means <- tapply(closest_data[[num_var]], closest_data[[cat_var]], mean, na.rm = TRUE)
# Extract categorical levels and their means from the overall_means vector
cat_levels <- if (is.null(names(overall_means))) {
unique(closest_data[[cat_var]])
} else {
names(overall_means)
}
mean_values <- as.numeric(overall_means)
# Ensure cat_levels and mean_values are of the same length
if (length(cat_levels) != length(mean_values)) {
stop("Mismatch between categorical levels and their overall means.")
}
# Plot the violin plot
p <- ggplot(closest_data, aes(x = get(cat_var), y = get(num_var))) +
geom_violin(aes(fill = get(cat_var)), alpha = 0.7) +
geom_jitter(width = 0.2, size = 1, alpha = 0.7, shape = 20) +  # Change here
geom_point(data = data.frame(cat = names(dataset_means), mean = dataset_means),
aes(x = cat, y = mean), color = "#242121", size = 4, shape = 24) +
geom_point(data = data.frame(cat = cat_levels, mean = mean_values),
aes(x = cat, y = mean), color = "#706966", size = 4, shape = 25) +
labs(title = paste("Violin plot of", num_var, "by", cat_var),
x = cat_var, y = num_var, fill = cat_var) +
theme_gray() +
scale_fill_manual(values = c("Fw" = "#42C092", "Nw" = "#42ABC0"))
return(p)
}
tryy<-plotBoot(representative_data$closest_data, "focal_dant", "focal_morph", representative_data$overall_means)
tryy
plotBoot <- function(closest_data, num_var, cat_var, overall_means) {
library(ggplot2)
# Calculate dataset means for each level
dataset_means <- tapply(closest_data[[num_var]], closest_data[[cat_var]], mean, na.rm = TRUE)
# Extract categorical levels and their means from the overall_means vector
cat_levels <- if (is.null(names(overall_means))) {
unique(closest_data[[cat_var]])
} else {
names(overall_means)
}
mean_values <- as.numeric(overall_means)
# Ensure cat_levels and mean_values are of the same length
if (length(cat_levels) != length(mean_values)) {
stop("Mismatch between categorical levels and their overall means.")
}
# Plot the violin plot
p <- ggplot(closest_data, aes(x = get(cat_var), y = get(num_var))) +
geom_violin(aes(fill = get(cat_var)), alpha = 0.7) +
geom_jitter(width = 0.2, size = 1, alpha = 0.7, shape = 20) +  # Change here
geom_point(data = data.frame(cat = names(dataset_means), mean = dataset_means),
aes(x = cat, y = mean), color = "#242121", size = 4, shape = 19) +
geom_point(data = data.frame(cat = cat_levels, mean = mean_values),
aes(x = cat, y = mean), color = "#706966", size = 4, shape = 21) +
labs(title = paste("Violin plot of", num_var, "by", cat_var),
x = cat_var, y = num_var, fill = cat_var) +
theme_gray() +
scale_fill_manual(values = c("Fw" = "#42C092", "Nw" = "#42ABC0"))
return(p)
}
tryy<-plotBoot(representative_data$closest_data, "focal_dant", "focal_morph", representative_data$overall_means)
tryy
plotBoot <- function(closest_data, num_var, cat_var, overall_means) {
library(ggplot2)
# Calculate dataset means for each level
dataset_means <- tapply(closest_data[[num_var]], closest_data[[cat_var]], mean, na.rm = TRUE)
# Extract categorical levels and their means from the overall_means vector
cat_levels <- if (is.null(names(overall_means))) {
unique(closest_data[[cat_var]])
} else {
names(overall_means)
}
mean_values <- as.numeric(overall_means)
# Ensure cat_levels and mean_values are of the same length
if (length(cat_levels) != length(mean_values)) {
stop("Mismatch between categorical levels and their overall means.")
}
# Plot the violin plot
p <- ggplot(closest_data, aes(x = get(cat_var), y = get(num_var))) +
geom_violin(aes(fill = get(cat_var)), alpha = 0.7) +
geom_jitter(width = 0.2, size = 1, alpha = 0.7, shape = 20) +  # Change here
geom_point(data = data.frame(cat = names(dataset_means), mean = dataset_means),
aes(x = cat, y = mean), color = "#242121", size = 2, shape = 19) +
geom_point(data = data.frame(cat = cat_levels, mean = mean_values),
aes(x = cat, y = mean), color = "#706966", size = 4, shape = 21) +
labs(title = paste("Violin plot of", num_var, "by", cat_var),
x = cat_var, y = num_var, fill = cat_var) +
theme_gray() +
scale_fill_manual(values = c("Fw" = "#42C092", "Nw" = "#42ABC0"))
return(p)
}
tryy<-plotBoot(representative_data$closest_data, "focal_dant", "focal_morph", representative_data$overall_means)
tryy
plotBoot <- function(closest_data, num_var, cat_var, overall_means) {
library(ggplot2)
# Calculate dataset means for each level
dataset_means <- tapply(closest_data[[num_var]], closest_data[[cat_var]], mean, na.rm = TRUE)
# Extract categorical levels and their means from the overall_means vector
cat_levels <- if (is.null(names(overall_means))) {
unique(closest_data[[cat_var]])
} else {
names(overall_means)
}
mean_values <- as.numeric(overall_means)
# Ensure cat_levels and mean_values are of the same length
if (length(cat_levels) != length(mean_values)) {
stop("Mismatch between categorical levels and their overall means.")
}
# Plot the violin plot
p <- ggplot(closest_data, aes(x = get(cat_var), y = get(num_var))) +
geom_violin(aes(fill = get(cat_var)), alpha = 0.7) +
geom_jitter(width = 0.2, size = 1, alpha = 0.7, shape = 20) +  # Change here
geom_point(data = data.frame(cat = names(dataset_means), mean = dataset_means),
aes(x = cat, y = mean), color = "#242121", size = 2, shape = 15) +
geom_point(data = data.frame(cat = cat_levels, mean = mean_values),
aes(x = cat, y = mean), color = "#706966", size = 4, shape = 17) +
labs(title = paste("Violin plot of", num_var, "by", cat_var),
x = cat_var, y = num_var, fill = cat_var) +
theme_gray() +
scale_fill_manual(values = c("Fw" = "#42C092", "Nw" = "#42ABC0"))
return(p)
}
tryy<-plotBoot(representative_data$closest_data, "focal_dant", "focal_morph", representative_data$overall_means)
tryy
plotBoot <- function(closest_data, num_var, cat_var, overall_means) {
library(ggplot2)
# Calculate dataset means for each level
dataset_means <- tapply(closest_data[[num_var]], closest_data[[cat_var]], mean, na.rm = TRUE)
# Extract categorical levels and their means from the overall_means vector
cat_levels <- if (is.null(names(overall_means))) {
unique(closest_data[[cat_var]])
} else {
names(overall_means)
}
mean_values <- as.numeric(overall_means)
# Ensure cat_levels and mean_values are of the same length
if (length(cat_levels) != length(mean_values)) {
stop("Mismatch between categorical levels and their overall means.")
}
# Plot the violin plot
p <- ggplot(closest_data, aes(x = get(cat_var), y = get(num_var))) +
geom_violin(aes(fill = get(cat_var)), alpha = 0.7) +
geom_jitter(width = 0.2, size = 1, alpha = 0.7, shape = 20) +  # Change here
geom_point(data = data.frame(cat = names(dataset_means), mean = dataset_means),
aes(x = cat, y = mean), color = "#242121", size = 4, shape = 15) +
geom_point(data = data.frame(cat = cat_levels, mean = mean_values),
aes(x = cat, y = mean), color = "#706966", size = 4, shape = 17) +
labs(title = paste("Violin plot of", num_var, "by", cat_var),
x = cat_var, y = num_var, fill = cat_var) +
theme_gray() +
scale_fill_manual(values = c("Fw" = "#42C092", "Nw" = "#42ABC0"))
return(p)
}
tryy<-plotBoot(representative_data$closest_data, "focal_dant", "focal_morph", representative_data$overall_means)
tryy
randboot <- function(data, dyad_id_col, model_formula,
model_type = "lm", family = NULL,
n_bootstraps = 1000,
focal_cols, opposite_cols,
RE_formula = NULL, control = NULL,
max_iterations = 10000, # New parameter
max_time_seconds = 3600) { # New parameter: max execution time in seconds
start_time <- Sys.time() # Record the starting time
# Check for valid focal_cols and opposite_cols
if (!all(focal_cols %in% colnames(data))) {
stop("Some of the focal_cols are not found in the provided data.")
}
if (!all(opposite_cols %in% colnames(data))) {
stop("Some of the opposite_cols are not found in the provided data.")
}
# Split data by dyad
dyad_groups <- split(data, data[[dyad_id_col]])
# Function to create focal and opposite data
create_focal_opposite_data <- function(dyad_groups) {
focal_opposite_data_list <- lapply(dyad_groups, function(dyad) {
# Shuffle dyad members to randomly assign roles
shuffled_dyad <- dyad[sample(1:2), ]
# Create a new data frame with 'focal' and 'opposite' columns
focal_data <- shuffled_dyad[1, , drop = FALSE]
colnames(focal_data) <- paste0("focal_", colnames(focal_data))
opposite_data <- shuffled_dyad[2, , drop = FALSE]
colnames(opposite_data) <- paste0("opposite_", colnames(opposite_data))
# Combine the data into a single row
combined_data <- cbind(focal_data, opposite_data)
return(combined_data)
})
# Combine all dyads back into a single data frame
focal_opposite_data <- do.call(rbind, focal_opposite_data_list)
return(focal_opposite_data)
}
# Bootstrap function
bootstrap_glmp <- function(dyad_groups, n_bootstraps = 1000) {
bootstrapped_results <- vector("list", length = n_bootstraps)
iteration_count <- 0 # Initialize the iteration counter
for (i in 1:n_bootstraps) {
# Check if maximum iterations or maximum time has been reached
iteration_count <- iteration_count + 1
if (iteration_count > max_iterations) {
stop("Maximum iteration limit reached.")
}
if (difftime(Sys.time(), start_time, units = "secs") > max_time_seconds) {
stop("Maximum execution time limit reached.")
}
focal_opposite_data <- create_focal_opposite_data(dyad_groups)
# Determine which model to run based on model_type
if (model_type == "lm") {
model <- lm(model_formula, data = focal_opposite_data)
} else if (model_type == "glm") {
if (is.null(family)) stop("Please specify a family for the glm model.")
model <- glm(model_formula, data = focal_opposite_data, family = family)
} else if (model_type == "lmer") {
if (!requireNamespace("lme4", quietly = TRUE)) {
stop("The 'lme4' package is required for mixed-effects models. Please install it using install.packages('lme4').")
}
if (is.null(RE_formula)) stop("Please specify random effects for the lmer model.")
full_formula <- update(model_formula, . ~ . + (RE_formula))
model <- lme4::lmer(full_formula, data = focal_opposite_data, control = control)
} else if (model_type == "glmer") {
if (!requireNamespace("lme4", quietly = TRUE)) {
stop("The 'lme4' package is required for mixed-effects models. Please install it using install.packages('lme4').")
}
if (is.null(family)) stop("Please specify a family for the glmer model.")
if (is.null(RE_formula)) stop("Please specify random effects for the glmer model.")
full_formula <- update(model_formula, . ~ . + (RE_formula))
model <- lme4::glmer(full_formula, data = focal_opposite_data, family = family, control = control)
} else {
stop("Invalid model_type specified. Choose 'lm', 'glm', 'lmer', or 'glmer'.")
}
bootstrapped_results[[i]] <- list(model = model, summary = summary(model))
}
return(bootstrapped_results)
}
# Ensure warnings from underlying functions are displayed immediately
results <- withCallingHandlers({
bootstrap_glmp(dyad_groups, n_bootstraps = n_bootstraps)
}, warning = function(w) {
# Print warnings immediately
print(w)
invokeRestart("muffleWarning")
})
return(list(bootstrap_results = results))
}
model_formula <- focal_dant ~ focal_morph
results <- DyadBoot::randboot(data = mydata,
dyad_id_col = "dyad_id",
model_formula = model_formula,
model_type = "lm",
n_bootstraps = 50,
focal_cols = c("focal_dant"),
opposite_cols = c("focal_dant"))
View(mydata)
results <- DyadBoot::randboot(data = mydata,
dyad_id_col = "dyad_id",
model_formula = model_formula,
model_type = "lm",
n_bootstraps = 50,
focal_cols = c("dant"),
opposite_cols = c("dant"))
results$bootstrap_results
histPvals(results$bootstrap_results, "focal_morphNw")
histPvals <- function(bootstrap_results, coeff_name, max_iterations = 10000) {
# Helper function to extract the p-value for a given coefficient from a model summary
extract_pvalue <- function(model_summary, coeff_name) {
coeffs <- model_summary$coefficients
if(coeff_name %in% rownames(coeffs)) {
return(coeffs[coeff_name, "Pr(>|t|)"])
} else {
stop(paste("Coefficient", coeff_name, "not found in the model summary."))
}
}
# Extract p-values for the specified coefficient across all bootstrap iterations
iteration <- 0
pvalues <- sapply(bootstrap_results, function(res) {
iteration <<- iteration + 1
if(iteration > max_iterations) stop("Maximum iterations reached!")
return(extract_pvalue(res$summary, coeff_name))
})
# Plot a histogram of the p-values
hist_info <- hist(pvalues, breaks = seq(0, 1, by = 0.05), main = paste("Histogram of p-values for", coeff_name),
xlab = "p-value", ylab = "Frequency", col = "lightblue", border = "black")
# Add a dashed vertical line at x = 0.05
abline(v = 0.05, lty = 2, col = "red")
# Determine the number of iterations with p < 0.05
significant_iterations <- sum(pvalues < 0.05)
# Add the text to the plot
text(x = 0.8, y = max(hist_info$counts) * 0.9,
labels = paste("# iterations p < 0.05:", significant_iterations),
col = "black")
}
histPvals(results$bootstrap_results, "focal_morphNw")
histPvals(results$bootstrap_results, "focal_morphFw")
histPvals(results$bootstrap_results, "focal_morphNw - 1")
histPvals(results$bootstrap_results, "focal_morphNw")
model_formula <- focal_dant ~ opposite_morph
results <- DyadBoot::randboot(data = mydata,
dyad_id_col = "dyad_id",
model_formula = model_formula,
model_type = "lm",
n_bootstraps = 50,
focal_cols = c("dant"),
opposite_cols = c("dant"))
results$bootstrap_results
histPvals(results$bootstrap_results, "opposite_morphNw")
model_formula <- focal_dant ~ focal_group
results <- DyadBoot::randboot(data = mydata,
dyad_id_col = "dyad_id",
model_formula = model_formula,
model_type = "lm",
n_bootstraps = 50,
focal_cols = c("dant"),
opposite_cols = c("dant"))
results$bootstrap_results
histPvals(results$bootstrap_results, "focal_groupC")
histPvals(results$bootstrap_results, "focal_groupB")
resultsMult <- randMult(mydata, dyad_id_col = "dyad_id", num_iterations = 1000)
representative_data<- repDataSet(resultsMult, "focal_dant", "focal_group")
representative_data$closest_data
representative_data$overall_means
plot<-histMeans(representative_data$all_means, "focal_dant", "focal_group", "C")
plot
plot<-histMeans(representative_data$all_means, "focal_dant", "focal_group", "A")
plot
plot<-histMeans(representative_data$all_means, "focal_dant", "focal_group", "B")
plot
plot<-histMeans(representative_data$all_means, "focal_dant", "focal_group", "C")
plot
tryy<-plotBoot(representative_data$closest_data, "focal_dant", "focal_group", representative_data$overall_means)
tryy
resultsMult <- randMult(mydata, dyad_id_col = "dyad_id", num_iterations = 50)
resultsMult$results_list
representative_data<- repDataSet(resultsMult, "focal_dant", "focal_group")
representative_data$closest_data
representative_data$overall_means
plot<-histMeans(representative_data$all_means, "focal_dant", "focal_group", "C")
plot
plot<-histMeans(representative_data$all_means, "focal_dant", "focal_group", "A")
plot
plot<-histMeans(representative_data$all_means, "focal_dant", "focal_group", "B")
plot
tryy<-plotBoot(representative_data$closest_data, "focal_dant", "focal_group", representative_data$overall_means)
tryy
resultsMult <- randMult(mydata, dyad_id_col = "dyad_id", num_iterations = 1000)
representative_data<- repDataSet(resultsMult, "focal_dant", "focal_group")
representative_data$closest_data
representative_data$overall_means
representative_data<- repDataSet(resultsMult, "focal_dant", "opposite_group")
representative_data$closest_data
representative_data$overall_means
resultsMult <- randMult(mydata, dyad_id_col = "dyad_id", num_iterations = 500)
plot<-histMeans(representative_data$all_means, "focal_dant", "focal_group", "A")
plot
plot<-histMeans(representative_data$all_means, "focal_dant", "focal_group", "B")
plot
plot<-histMeans(representative_data$all_means, "focal_dant", "focal_group", "C")
plot
representative_data<- repDataSet(resultsMult, "focal_dant", "opposite_group")
representative_data$closest_data
representative_data$overall_means
resultsMult <- randMult(mydata, dyad_id_col = "dyad_id", num_iterations = 50)
resultsMult$results_list
representative_data<- repDataSet(resultsMult, "focal_dant", "opposite_group")
representative_data$closest_data
representative_data$overall_means
overall_means <- sapply(levels, function(level) {
mean(all_means_df[[level]], na.rm = TRUE)
})
